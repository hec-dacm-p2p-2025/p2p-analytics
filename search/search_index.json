{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p><code>p2p-analytics</code> is a lightweight analysis package built on top of the automated Binance P2P / BCB data pipeline developed in Phase 1 of the project. It provides reusable functions for exploring market structure, spreads, premiums, behavior across fiat currencies, and short-term volatility patterns.</p> <p>The package consumes the parquet datasets generated by Phase 1 and produces ready-to-visualize tables for Phase 3 dashboards (Power BI).</p>"},{"location":"#key-capabilities","title":"Key capabilities","text":"<ul> <li>Load Binance P2P data or official exchange rates through unified loader functions</li> <li>Compute BUY\u2013SELL spreads and intraday price profiles</li> <li>Compare fiat markets across countries</li> <li>Measure premium vs. official exchange rate</li> <li>Analyze microstructure (order imbalance, liquidity signals)</li> <li>Produce summary statistics and rolling volatility indicators</li> <li>Export outputs directly into Power BI-friendly files</li> </ul> <p>This package is meant to be simple, modular, and easy to integrate into any downstream analytics workflow.</p>"},{"location":"examples/","title":"Examples","text":"<p>This page provides practical workflow using <code>p2p_analytics</code>.</p>"},{"location":"examples/#example-1-spread-dynamics-over-time","title":"Example 1 - Spread dynamics over time","text":"<pre><code>import matplotlib.pyplot as plt\nfrom p2p_analytics import p2p_spread\n\nspread = p2p_spread(\"ARS\", by=\"day\", root=PHASE1_ROOT)\n\nplt.plot(spread[\"date\"], spread[\"spread_abs\"])\nplt.title(\"ARS Daily BUY\u2013SELL Spread\")\nplt.ylabel(\"Spread (ARS)\")\nplt.xlabel(\"Date\")\nplt.show()\n</code></pre>"},{"location":"examples/#example-2-multi-currency-comparison","title":"Example 2 - Multi-currency comparison","text":"<pre><code>from p2p_analytics import fiat_comparison\n\nfx = fiat_comparison([\"ARS\", \"BOB\", \"MXN\"], root=PHASE1_ROOT)\nprint(fx.head())\n</code></pre>"},{"location":"examples/#example-3-exporting-to-power-bi","title":"Example 3 - Exporting to Power BI","text":"<pre><code>from p2p_analytics import p2p_summary\n\nsummary = p2p_summary(\"ARS\", root=PHASE1_ROOT)\n\nsummary.to_parquet(\"exports/summary_ARS.parquet\", index=False)\nsummary.to_csv(\"exports/summary_ARS.csv\", index=False)\n</code></pre>"},{"location":"get_started/","title":"Get started","text":"<p>This page shows how to perform the most common tasks with <code>p2p-analytics</code>.</p>"},{"location":"get_started/#define-correct-root-path","title":"Define correct root path","text":"<p>Before loading any data, make sure to set the correct root path where the Phase 1 pipeline has stored the parquet datasets. Compute the following code in the phase 3 notebook:</p> <pre><code>from pathlib import Path\n\nPHASE1_ROOT = Path(\"../final-project/phase1_data_pipeline/data/processed\").resolve()\n</code></pre>"},{"location":"get_started/#load-data","title":"Load data","text":"<p>The package provides a collection of loader functions that read the parquet datasets generated by the Phase 1 pipeline.</p> <pre><code>from p2p_analytics import load_binance_currency, load_bcb_master\n\ndf_ars = load_binance_currency(\"ARS\")\nbcb = load_bcb_master()\n</code></pre>"},{"location":"get_started/#compute-spread","title":"Compute spread","text":"<pre><code>from p2p_analytics import p2p_spread\n\nspread_ars = p2p_spread(\"ARS\", by=\"day\", root=PHASE1_ROOT)\n</code></pre>"},{"location":"get_started/#intraday-profile","title":"Intraday profile","text":"<pre><code>from p2p_analytics import intraday_profile\n\nprofile_ars = intraday_profile(\"ARS\", root=PHASE1_ROOT)\n</code></pre>"},{"location":"get_started/#compare-multiple-currencies","title":"Compare multiple currencies","text":"<pre><code>from p2p_analytics import fiat_comparison\n\nfiats = fiat_comparison([\"ARS\", \"BOB\", \"MXN\"], root=PHASE1_ROOT)\n</code></pre>"},{"location":"get_started/#premium-vs-official-exchange-rate","title":"Premium vs. official exchange rate","text":"<pre><code>from p2p_analytics import official_premium\n\npremium_ars = official_premium(\"ARS\", root=PHASE1_ROOT)\n</code></pre>"},{"location":"get_started/#volatility-and-summary-statistics","title":"Volatility and summary statistics","text":"<pre><code>from p2p_analytics import p2p_summary, price_volatility\n\nsummary_ars = p2p_summary(\"ARS\", root=PHASE1_ROOT)\nvol_ars = price_volatility(\"ARS\", window=7, root=PHASE1_ROOT)\n</code></pre>"},{"location":"get_started/#outputs","title":"Outputs","text":"<p>All outputs are standard pandas DataFrame and can be exported directly to PowerBI:</p> <pre><code>summary_ars.to_parquet(\"exports/summary_ARS.parquet\") # exports in .parquet file\n\nsummary_ars.to_csv(\"exports/summary_ARS.csv\") # exports in .csv file\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#1-clone-the-main-project-repository","title":"1. Clone the main project repository","text":"<pre><code>git clone https://github.com/hec-dacm-p2p-2025/final-project.git\n</code></pre>"},{"location":"installation/#2-create-and-activate-a-virtual-environment","title":"2. Create and activate a virtual environment","text":"<p>Windows</p> <pre><code>python -m venv .venv\n.\\.venv\\Scripts\\activate\n</code></pre> <p>macOS/Linux</p> <pre><code>python3 -m venv .venv\nsource .venv/bin/activate\n</code></pre>"},{"location":"installation/#3-install-the-package-in-editable-mode","title":"3. Install the package in editable mode","text":"<pre><code>pip install -e ../p2p-analytics/phase2_package\n</code></pre> <p>This install all required runtime dependencies and all developer tools: <code>pytest</code>, <code>ruff</code>, <code>mypy</code>, <code>mkdocs</code>, etc.. from the local package repository.</p>"},{"location":"installation/#4-verify-installation","title":"4. Verify installation","text":"<p>Open a Python shell and run: </p> <pre><code>import p2p_analytics\np2p_analytics.__file__\n</code></pre> <p>If no error appears and you see something like: \".../p2p-analytics/phase2_package/src/p2p_analytics/init.py\" , the package is successfully installed.</p>"},{"location":"api/io/","title":"Data Loading Functions","text":""},{"location":"api/io/#p2p_analytics.io.get_processed_root","title":"<code>get_processed_root(root=None)</code>","text":"<p>Return the root path to the Phase 1 processed data.</p> <p>If <code>root</code> is None, we assume the following project layout:</p> <pre><code>GitHub/\n\u251c\u2500 final-project/\n\u2502   \u2514\u2500 phase1_data_pipeline/...\n\u2514\u2500 p2p-analytics/\n    \u2514\u2500 phase2_package/...\n        \u2514\u2500 src/p2p_analytics/...\n</code></pre> <p>If <code>root</code> is provided, it is used directly. Otherwise, a ValueError is raised to force the user to be explicit.</p> Source code in <code>src\\p2p_analytics\\io.py</code> <pre><code>def get_processed_root(root: Optional[PathLike] = None) -&gt; Path:\n    \"\"\"\n    Return the root path to the Phase 1 processed data.\n\n    If `root` is None, we assume the following project layout:\n\n        GitHub/\n        \u251c\u2500 final-project/\n        \u2502   \u2514\u2500 phase1_data_pipeline/...\n        \u2514\u2500 p2p-analytics/\n            \u2514\u2500 phase2_package/...\n                \u2514\u2500 src/p2p_analytics/...\n\n    If `root` is provided, it is used directly.\n    Otherwise, a ValueError is raised to force the user to be explicit.\n    \"\"\"\n    if root is not None:\n        return Path(root).expanduser().resolve()\n\n    raise ValueError(\n        \"No Phase 1 processed-data path provided. \"\n        \"Pass `root=` explicitly when calling loader functions.\"\n    )\n</code></pre>"},{"location":"api/io/#p2p_analytics.io.load_bcb_latest","title":"<code>load_bcb_latest(root=None)</code>","text":"<p>Load the most recent BCB official rates (e.g. today's table). This function reads from: <code>&lt;processed_root&gt;/bcb/bcb_today.parquet</code></p> Source code in <code>src\\p2p_analytics\\io.py</code> <pre><code>def load_bcb_latest(root: Optional[PathLike] = None) -&gt; pd.DataFrame:\n    \"\"\"\n    Load the most recent BCB official rates (e.g. today's table). This function reads from: `&lt;processed_root&gt;/bcb/bcb_today.parquet`\n    \"\"\"\n    processed_root = get_processed_root(root)\n    path = processed_root / \"bcb\" / \"bcb_today.parquet\"\n    return pd.read_parquet(path)\n</code></pre>"},{"location":"api/io/#p2p_analytics.io.load_bcb_master","title":"<code>load_bcb_master(root=None)</code>","text":"<p>Load the full BCB official-rate history.It reads from: <code>&lt;processed_root&gt;/bcb/bcb_master.parquet</code></p> Source code in <code>src\\p2p_analytics\\io.py</code> <pre><code>def load_bcb_master(root: Optional[PathLike] = None) -&gt; pd.DataFrame:\n    \"\"\"\n    Load the full BCB official-rate history.It reads from: `&lt;processed_root&gt;/bcb/bcb_master.parquet`\n    \"\"\"\n    processed_root = get_processed_root(root)\n    path = processed_root / \"bcb\" / \"bcb_master.parquet\"\n    return pd.read_parquet(path)\n</code></pre>"},{"location":"api/io/#p2p_analytics.io.load_binance_currency","title":"<code>load_binance_currency(currency, root=None)</code>","text":"<p>Load historical Binance P2P data for a single fiat currency. It reads from: <code>&lt;processed_root&gt;/binance/historical_fiat/&lt;CURRENCY&gt;.parquet</code></p> Source code in <code>src\\p2p_analytics\\io.py</code> <pre><code>def load_binance_currency(\n    currency: str,\n    root: Optional[PathLike] = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Load historical Binance P2P data for a single fiat currency. It reads from: `&lt;processed_root&gt;/binance/historical_fiat/&lt;CURRENCY&gt;.parquet`\n    \"\"\"\n    processed_root = get_processed_root(root)\n    path = processed_root / \"binance\" / \"historical_fiat\" / f\"{currency}.parquet\"\n    return pd.read_parquet(path)\n</code></pre>"},{"location":"api/io/#p2p_analytics.io.load_binance_daily","title":"<code>load_binance_daily(date, root=None)</code>","text":"<p>Load one daily snapshot of Binance P2P data.</p> <p>Parameters:</p> Name Type Description Default <code>date</code> <code>str or datetime.date Date of interest; if string, should be 'YYYY-MM-DD'. This function reads from: `&lt;processed_root&gt;/binance/daily_snapshots/daily_snapshot_&lt;YYYY-MM-DD&gt;.parquet`</code> required Source code in <code>src\\p2p_analytics\\io.py</code> <pre><code>def load_binance_daily(\n    date: Union[str, dt.date],\n    root: Optional[PathLike] = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Load one daily snapshot of Binance P2P data.\n\n    Parameters\n    ----------\n    date : str or datetime.date Date of interest; if string, should be 'YYYY-MM-DD'. This function reads from: `&lt;processed_root&gt;/binance/daily_snapshots/daily_snapshot_&lt;YYYY-MM-DD&gt;.parquet`\n    \"\"\"\n    if isinstance(date, dt.date):\n        date_str = date.strftime(\"%Y-%m-%d\")\n    else:\n        date_str = str(date)\n\n    processed_root = get_processed_root(root)\n    filename = f\"daily_snapshot_{date_str}.parquet\"\n    path = processed_root / \"binance\" / \"daily_snapshots\" / filename\n    return pd.read_parquet(path)\n</code></pre>"},{"location":"api/io/#p2p_analytics.io.load_binance_master","title":"<code>load_binance_master(root=None)</code>","text":"<p>Load the full Binance P2P history (all fiats, all time). It reads from: <code>&lt;processed_root&gt;/binance/p2p_master.parquet</code></p> Source code in <code>src\\p2p_analytics\\io.py</code> <pre><code>def load_binance_master(root: Optional[PathLike] = None) -&gt; pd.DataFrame:\n    \"\"\"\n    Load the full Binance P2P history (all fiats, all time). It reads from: `&lt;processed_root&gt;/binance/p2p_master.parquet`\n    \"\"\"\n    processed_root = get_processed_root(root)\n    path = processed_root / \"binance\" / \"p2p_master.parquet\"\n    return pd.read_parquet(path)\n</code></pre>"},{"location":"api/microstructure/","title":"Microstructure Indicators","text":""},{"location":"api/microstructure/#p2p_analytics.microstructure.order_imbalance","title":"<code>order_imbalance(currency, by='hour', root=None)</code>","text":"<p>Compute hourly order imbalance for a given currency using historical_fiat data.</p> <p>Parameters:</p> Name Type Description Default <code>currency</code> <code>str</code> <p>Fiat currency code.</p> required <code>by</code> <code>hour</code> <p>Aggregation level.</p> <code>'hour'</code> <code>root</code> <code>path - like</code> <p>Root of processed data from Phase 1.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>One row per (date, hour) with: - date - hour - currency - buy_volume - sell_volume - imbalance</p> Source code in <code>src\\p2p_analytics\\microstructure.py</code> <pre><code>def order_imbalance(\n    currency: str,\n    by: Literal[\"hour\"] = \"hour\",\n    root: str | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute hourly order imbalance for a given currency using historical_fiat data.\n\n    Parameters\n    ----------\n    currency : str\n        Fiat currency code.\n    by : {'hour'}, default 'hour'\n        Aggregation level.\n    root : path-like, optional\n        Root of processed data from Phase 1.\n\n    Returns\n    -------\n    pandas.DataFrame\n        One row per (date, hour) with:\n        - date\n        - hour\n        - currency\n        - buy_volume\n        - sell_volume\n        - imbalance\n    \"\"\"\n    df = load_binance_currency(currency, root=root)\n    return _order_imbalance_core(df, currency, by=by)\n</code></pre>"},{"location":"api/premium/","title":"Premium vs. Official  Exchange Rate","text":""},{"location":"api/premium/#p2p_analytics.premium.official_premium","title":"<code>official_premium(currency, by='day', root=None)</code>","text":"<p>Compare P2P prices vs official BCB rate for a given currency.</p> <p>Parameters:</p> Name Type Description Default <code>currency</code> <code>str</code> <p>Fiat currency code.</p> required <code>by</code> <code>day</code> <p>Aggregation level (currently only daily).</p> <code>'day'</code> <code>root</code> <code>path - like</code> <p>Root of processed data from Phase 1.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Columns: - date - currency - p2p_avg_price - official_exchange_rate - premium_abs - premium_pct</p> Source code in <code>src\\p2p_analytics\\premium.py</code> <pre><code>def official_premium(\n    currency: str,\n    by: Literal[\"day\"] = \"day\",\n    root: str | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compare P2P prices vs official BCB rate for a given currency.\n\n    Parameters\n    ----------\n    currency : str\n        Fiat currency code.\n    by : {'day'}, default 'day'\n        Aggregation level (currently only daily).\n    root : path-like, optional\n        Root of processed data from Phase 1.\n\n    Returns\n    -------\n    pandas.DataFrame\n        Columns:\n        - date\n        - currency\n        - p2p_avg_price\n        - official_exchange_rate\n        - premium_abs\n        - premium_pct\n    \"\"\"\n    if by != \"day\":\n        raise NotImplementedError(\"Only by='day' is implemented for now.\")\n\n    # 1) Binance daily mid-price\n    df_binance = load_binance_currency(currency, root=root)\n    daily = _p2p_spread_core(df_binance, currency, by=\"day\")\n    # mid-market price\n    daily[\"p2p_avg_price\"] = (daily[\"avg_buy_price\"] + daily[\"avg_sell_price\"]) / 2\n\n    # 2) BCB official rate\n    df_bcb = load_bcb_master(root=root)\n    df_bcb_cur = df_bcb[df_bcb[\"currency\"] == currency].copy()\n\n    merged = daily.merge(\n        df_bcb_cur[[\"date\", \"currency\", \"official_exchange_rate\"]],\n        on=[\"date\", \"currency\"],\n        how=\"inner\",\n    )\n\n    merged[\"premium_abs\"] = merged[\"p2p_avg_price\"] - merged[\"official_exchange_rate\"]\n    merged[\"premium_pct\"] = (\n        merged[\"p2p_avg_price\"] / merged[\"official_exchange_rate\"] - 1.0\n    ) * 100\n\n    return merged[[\n        \"date\",\n        \"currency\",\n        \"p2p_avg_price\",\n        \"official_exchange_rate\",\n        \"premium_abs\",\n        \"premium_pct\",\n    ]]\n</code></pre>"},{"location":"api/spreads/","title":"Spreads and Intraday Analysis","text":""},{"location":"api/spreads/#p2p_analytics.spreads.fiat_comparison","title":"<code>fiat_comparison(currencies, root=None)</code>","text":"<p>Build a comparison table across multiple fiat currencies (daily metrics).</p> <p>Parameters:</p> Name Type Description Default <code>currencies</code> <code>sequence of str</code> <p>List of fiat codes to include (e.g. ['ARS', 'BOB', 'EUR']).</p> required <code>root</code> <code>path - like</code> <p>Root of processed data.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>One row per date per currency, with: - date - currency - avg_buy_price - avg_sell_price - spread_abs - spread_pct</p> Source code in <code>src\\p2p_analytics\\spreads.py</code> <pre><code>def fiat_comparison(\n    currencies: Sequence[str],\n    root: str | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Build a comparison table across multiple fiat currencies (daily metrics).\n\n    Parameters\n    ----------\n    currencies : sequence of str\n        List of fiat codes to include (e.g. ['ARS', 'BOB', 'EUR']).\n    root : path-like, optional\n        Root of processed data.\n\n    Returns\n    -------\n    pandas.DataFrame\n        One row per date per currency, with:\n        - date\n        - currency\n        - avg_buy_price\n        - avg_sell_price\n        - spread_abs\n        - spread_pct\n    \"\"\"\n    df = load_binance_master(root=root)\n    df_sub = df[df[\"currency\"].isin(currencies)].copy()\n\n    grouped = (\n        df_sub\n        .groupby([\"date\", \"currency\", \"side\"], as_index=False)[\"price\"]\n        .mean()\n        .pivot_table(\n            index=[\"date\", \"currency\"],\n            columns=\"side\",\n            values=\"price\"\n        )\n        .rename(columns={\"BUY\": \"avg_buy_price\", \"SELL\": \"avg_sell_price\"})\n        .reset_index()\n    )\n\n    grouped[\"spread_abs\"] = (grouped[\"avg_sell_price\"] - grouped[\"avg_buy_price\"]).abs()\n    mid = (grouped[\"avg_sell_price\"] + grouped[\"avg_buy_price\"]) / 2\n    grouped[\"spread_pct\"] = grouped[\"spread_abs\"] / mid * 100\n\n    return grouped\n</code></pre>"},{"location":"api/spreads/#p2p_analytics.spreads.intraday_profile","title":"<code>intraday_profile(currency, root=None)</code>","text":"<p>Intraday price profile for a given currency (average over all days).</p> <p>Parameters:</p> Name Type Description Default <code>currency</code> <code>str</code> <p>Fiat currency code.</p> required <code>root</code> <code>path - like</code> <p>Root of processed data.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>One row per hour (0\u201323) with: - hour - currency - mean_buy_price - mean_sell_price</p> Source code in <code>src\\p2p_analytics\\spreads.py</code> <pre><code>def intraday_profile(\n    currency: str,\n    root: str | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Intraday price profile for a given currency (average over all days).\n\n    Parameters\n    ----------\n    currency : str\n        Fiat currency code.\n    root : path-like, optional\n        Root of processed data.\n\n    Returns\n    -------\n    pandas.DataFrame\n        One row per hour (0\u201323) with:\n        - hour\n        - currency\n        - mean_buy_price\n        - mean_sell_price\n    \"\"\"\n    df = load_binance_currency(currency, root=root)\n    df = _ensure_datetime(df, \"scrape_datetime\")\n    df_cur = df.copy()\n    df_cur[\"hour\"] = df_cur[\"scrape_datetime\"].dt.hour\n\n    grouped = (\n        df_cur\n        .groupby([\"hour\", \"side\"], as_index=False)[\"price\"]\n        .mean()\n        .pivot_table(\n            index=\"hour\",\n            columns=\"side\",\n            values=\"price\"\n        )\n        .rename(columns={\"BUY\": \"mean_buy_price\", \"SELL\": \"mean_sell_price\"})\n        .reset_index()\n    )\n\n    grouped[\"currency\"] = currency\n    return grouped\n</code></pre>"},{"location":"api/spreads/#p2p_analytics.spreads.p2p_spread","title":"<code>p2p_spread(currency, by='day', root=None)</code>","text":"<p>Compute BUY\u2013SELL spread for a given currency using the Phase 1 parquet files.</p> <p>Parameters:</p> Name Type Description Default <code>currency</code> <code>str</code> <p>Fiat code, e.g. 'ARS', 'BOB', 'EUR'.</p> required <code>by</code> <code>(day, hour)</code> <p>Aggregation level for spreads.</p> <code>'day'</code> <code>root</code> <code>path - like</code> <p>Root of processed data. If None, infer from project layout.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Columns include: - date (and hour if by='hour') - currency - avg_buy_price - avg_sell_price - spread_abs - spread_pct</p> Source code in <code>src\\p2p_analytics\\spreads.py</code> <pre><code>def p2p_spread(\n    currency: str,\n    by: ByType = \"day\",\n    root: str | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute BUY\u2013SELL spread for a given currency using the Phase 1 parquet files.\n\n    Parameters\n    ----------\n    currency : str\n        Fiat code, e.g. 'ARS', 'BOB', 'EUR'.\n    by : {'day', 'hour'}, default 'day'\n        Aggregation level for spreads.\n    root : path-like, optional\n        Root of processed data. If None, infer from project layout.\n\n    Returns\n    -------\n    pandas.DataFrame\n        Columns include:\n        - date (and hour if by='hour')\n        - currency\n        - avg_buy_price\n        - avg_sell_price\n        - spread_abs\n        - spread_pct\n    \"\"\"\n    df = load_binance_currency(currency, root=root)\n    return _p2p_spread_core(df, currency, by=by)\n</code></pre>"},{"location":"api/summary/","title":"Summary Statistics and Volatility","text":""},{"location":"api/summary/#p2p_analytics.summary.p2p_summary","title":"<code>p2p_summary(currency=None, currencies=None, by='day', root=None)</code>","text":"<p>Full P2P summary: prices, spreads, extremes, and changes vs previous period.</p> <p>If <code>currencies</code> is provided, uses the multi-currency master file. Otherwise, uses the per-currency historical file for <code>currency</code>.</p> Source code in <code>src\\p2p_analytics\\summary.py</code> <pre><code>def p2p_summary(\n    currency: Optional[str] = None,\n    currencies: Optional[Sequence[str]] = None,\n    by: ByType = \"day\",\n    root: str | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Full P2P summary: prices, spreads, extremes, and changes vs previous period.\n\n    If `currencies` is provided, uses the multi-currency master file.\n    Otherwise, uses the per-currency historical file for `currency`.\n    \"\"\"\n    if currencies is not None and currency is not None:\n        raise ValueError(\"Use either `currency` OR `currencies`, not both.\")\n\n    if currencies is not None:\n        df = load_binance_master(root=root)\n        df = df[df[\"currency\"].isin(currencies)].copy()\n    elif currency is not None:\n        df = load_binance_currency(currency, root=root)\n    else:\n        raise ValueError(\"You must provide either `currency` or `currencies`.\")\n\n    df, group_cols = _prepare_time_grouping(df, by)\n\n    # Aggregate BUY and SELL separately for min/max/mean\n    agg = (\n        df.groupby(group_cols + [\"side\"])\n        .agg(\n            avg_price=(\"price\", \"mean\"),\n            min_price=(\"price\", \"min\"),\n            max_price=(\"price\", \"max\"),\n        )\n        .reset_index()\n    )\n\n    # Pivot side to columns\n    summary = (\n        agg.pivot_table(\n            index=group_cols,\n            columns=\"side\",\n            values=[\"avg_price\", \"min_price\", \"max_price\"],\n        )\n        .reset_index()\n    )\n\n    # Flatten MultiIndex columns: ('avg_price', 'BUY') -&gt; 'avg_buy_price'\n    summary.columns = [\n        \"_\".join(col).strip(\"_\").lower().replace(\" \", \"_\")\n        if isinstance(col, tuple)\n        else col\n        for col in summary.columns\n    ]\n\n    # Rename for clarity\n    rename_map = {\n        \"avg_price_buy\": \"avg_buy_price\",\n        \"avg_price_sell\": \"avg_sell_price\",\n        \"min_price_buy\": \"min_buy_price\",\n        \"min_price_sell\": \"min_sell_price\",\n        \"max_price_buy\": \"max_buy_price\",\n        \"max_price_sell\": \"max_sell_price\",\n    }\n    summary = summary.rename(columns=rename_map)\n\n    # Mid price and spreads\n    summary[\"mid_price\"] = (summary[\"avg_buy_price\"] + summary[\"avg_sell_price\"]) / 2\n    summary[\"spread_abs\"] = (summary[\"avg_sell_price\"] - summary[\"avg_buy_price\"]).abs()\n    mid = summary[\"mid_price\"]\n    summary[\"spread_pct\"] = summary[\"spread_abs\"] / mid * 100\n\n    # Changes vs previous period, per currency\n    sort_cols = [\"currency\", \"date\"]\n    if by == \"hour\":\n        sort_cols.append(\"hour\")\n\n    summary = summary.sort_values(sort_cols).reset_index(drop=True)\n\n    summary[\"mid_price_change\"] = (\n        summary.groupby(\"currency\")[\"mid_price\"].diff()\n    )\n    summary[\"mid_price_pct_change\"] = (\n        summary.groupby(\"currency\")[\"mid_price\"].pct_change() * 100\n    )\n\n    summary[\"spread_abs_change\"] = (\n        summary.groupby(\"currency\")[\"spread_abs\"].diff()\n    )\n    summary[\"spread_pct_change\"] = (\n        summary.groupby(\"currency\")[\"spread_pct\"].diff()\n    )\n\n    return summary\n</code></pre>"},{"location":"api/summary/#p2p_analytics.summary.price_volatility","title":"<code>price_volatility(currency, by='day', window=7, root=None)</code>","text":"<p>Compute rolling volatility of the mid price over time.</p> <p>Volatility is defined as the rolling standard deviation of log-returns of the mid price over the given window size.</p> Source code in <code>src\\p2p_analytics\\summary.py</code> <pre><code>def price_volatility(\n    currency: str,\n    by: Literal[\"day\", \"hour\"] = \"day\",\n    window: int = 7,\n    root: str | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Compute rolling volatility of the mid price over time.\n\n    Volatility is defined as the rolling standard deviation of\n    log-returns of the mid price over the given window size.\n    \"\"\"\n    df = load_binance_currency(currency, root=root)\n    df, group_cols = _prepare_time_grouping(df, by)\n\n    # Daily / hourly mid price\n    agg = (\n        df.groupby(group_cols + [\"side\"], as_index=False)[\"price\"]\n        .mean()\n        .pivot_table(\n            index=group_cols,\n            columns=\"side\",\n            values=\"price\",\n        )\n        .rename(columns={\"BUY\": \"avg_buy_price\", \"SELL\": \"avg_sell_price\"})\n        .reset_index()\n    )\n\n    agg[\"mid_price\"] = (agg[\"avg_buy_price\"] + agg[\"avg_sell_price\"]) / 2\n\n    # Sort for time order\n    sort_cols = [\"currency\", \"date\"]\n    if by == \"hour\":\n        sort_cols.append(\"hour\")\n\n    agg = agg.sort_values(sort_cols).reset_index(drop=True)\n\n    # Log-returns and rolling std\n    agg[\"log_price\"] = np.log(agg[\"mid_price\"])\n    agg[\"log_return\"] = agg.groupby(\"currency\")[\"log_price\"].diff()\n\n    agg[\"volatility\"] = (\n        agg.groupby(\"currency\")[\"log_return\"]\n        .rolling(window=window)\n        .std()\n        .reset_index(level=0, drop=True)\n    )\n\n    return agg\n</code></pre>"},{"location":"api/summary/#p2p_analytics.summary.top_advertisers","title":"<code>top_advertisers(currency, side=None, start_date=None, end_date=None, metric='volume', n=10, root=None)</code>","text":"<p>Rank merchants by activity (ad count) and/or volume (sum of max_amount).</p> <p>Parameters:</p> Name Type Description Default <code>currency</code> <code>str</code> <p>Fiat currency code.</p> required <code>side</code> <code>('BUY', 'SELL')</code> <p>Filter by side if provided.</p> <code>'BUY'</code> <code>start_date</code> <code>'YYYY-MM-DD' or None</code> <p>Optional date range filter.</p> <code>None</code> <code>end_date</code> <code>'YYYY-MM-DD' or None</code> <p>Optional date range filter.</p> <code>None</code> <code>metric</code> <code>('volume', 'ads')</code> <p>Ranking metric: total volume (sum of max_amount) or number of ads.</p> <code>'volume'</code> <code>n</code> <code>int</code> <p>Number of top merchants to return.</p> <code>10</code> Source code in <code>src\\p2p_analytics\\summary.py</code> <pre><code>def top_advertisers(\n    currency: str,\n    side: Optional[str] = None,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n    metric: Literal[\"volume\", \"ads\"] = \"volume\",\n    n: int = 10,\n    root: str | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Rank merchants by activity (ad count) and/or volume (sum of max_amount).\n\n    Parameters\n    ----------\n    currency : str\n        Fiat currency code.\n    side : {'BUY', 'SELL'} or None\n        Filter by side if provided.\n    start_date, end_date : 'YYYY-MM-DD' or None\n        Optional date range filter.\n    metric : {'volume', 'ads'}\n        Ranking metric: total volume (sum of max_amount) or number of ads.\n    n : int\n        Number of top merchants to return.\n    \"\"\"\n    df = load_binance_currency(currency, root=root).copy()\n\n    # Filter by side\n    if side is not None:\n        df = df[df[\"side\"] == side]\n\n    # Ensure date is datetime-like for filtering\n    df[\"date\"] = pd.to_datetime(df[\"date\"]).dt.date\n\n    if start_date is not None:\n        start = pd.to_datetime(start_date).date()\n        df = df[df[\"date\"] &gt;= start]\n\n    if end_date is not None:\n        end = pd.to_datetime(end_date).date()\n        df = df[df[\"date\"] &lt;= end]\n\n    if df.empty:\n        return df.head(0)  # empty with same columns\n\n    grouped = (\n        df.groupby(\"merchant_name\")\n        .agg(\n            ads_count=(\"run_index\", \"count\"),\n            total_volume=(\"max_amount\", \"sum\"),\n            avg_finish_rate=(\"finish_rate\", \"mean\"),\n            avg_positive_rate=(\"positive_rate\", \"mean\"),\n        )\n        .reset_index()\n    )\n\n    if metric == \"volume\":\n        sort_col = \"total_volume\"\n    elif metric == \"ads\":\n        sort_col = \"ads_count\"\n    else:\n        raise ValueError(\"metric must be 'volume' or 'ads'.\")\n\n    grouped = grouped.sort_values(sort_col, ascending=False).head(n)\n    grouped[\"currency\"] = currency\n    if side is not None:\n        grouped[\"side\"] = side\n\n    return grouped\n</code></pre>"}]}